# ğŸ“‹ è¯¾å ‚äº’åŠ¨æ¨¡å— - å®Œæ•´å¼€å‘æµç¨‹æ–‡æ¡£

## ä¸€ã€æ¨¡å—æ¦‚è¿°

### 1.1 åŠŸèƒ½èŒƒå›´
è´Ÿè´£å®ç°è¯¾å ‚äº’åŠ¨çš„ä¸‰å¤§æ ¸å¿ƒåŠŸèƒ½ï¼š

#### åŠŸèƒ½1: å®æ—¶æŠ•ç¥¨
- **æ•™å¸ˆç«¯**: åœ¨è¯¾ç¨‹ä¸­åˆ›å»ºæŠ•ç¥¨é—®é¢˜ï¼ˆå•é€‰/å¤šé€‰ï¼‰
- **å­¦ç”Ÿç«¯**: é€‰æ‹©é€‰é¡¹å‚ä¸æŠ•ç¥¨
- **å±•ç¤º**: å®æ—¶ç»Ÿè®¡ç»“æœï¼Œå›¾è¡¨å¯è§†åŒ–
- **ç‰¹ç‚¹**: ç»“æ„åŒ–é€‰é¡¹ï¼Œç»Ÿè®¡åˆ†æ

#### åŠŸèƒ½2: è¯¾å ‚æé—®ï¼ˆç­”æ¡ˆå¼¹å¹•å±•ç¤ºï¼‰â­
- **æ•™å¸ˆç«¯**: åœ¨è¯¾ç¨‹ä¸­å‘å¸ƒå¼€æ”¾æ€§é—®é¢˜
- **å­¦ç”Ÿç«¯**: è¾“å…¥æ–‡å­—å›ç­”é—®é¢˜
- **å¼¹å¹•å±•ç¤º**: å­¦ç”Ÿçš„å›ç­”è‡ªåŠ¨è½¬æ¢ä¸ºå¼¹å¹•ï¼Œå®æ—¶æ»šåŠ¨å±•ç¤ºåœ¨å¤§å±å¹•ä¸Š
- **æ•™å¸ˆæ“ä½œ**: å¯ä»¥ç‚¹è¯„ç­”æ¡ˆã€é‡‡çº³ä¼˜ç§€ç­”æ¡ˆã€åˆ é™¤ä¸å½“å†…å®¹
- **ç‰¹ç‚¹**: å¼€æ”¾å¼å›ç­”ï¼Œå¼¹å¹•å½¢å¼å±•ç¤ºï¼Œäº’åŠ¨æ€§å¼º

#### åŠŸèƒ½3: è‡ªç”±å¼¹å¹•å¢™
- **æ‰€æœ‰ç”¨æˆ·**: å¯ä»¥è‡ªç”±å‘é€å¼¹å¹•ï¼ˆä¸é™äºå›ç­”é—®é¢˜ï¼‰
- **å±•ç¤º**: å®æ—¶æ»šåŠ¨å±•ç¤º
- **è¿‡æ»¤**: æ•æ„Ÿè¯è‡ªåŠ¨è¿‡æ»¤
- **ç‰¹ç‚¹**: è‡ªç”±è¡¨è¾¾ï¼Œæ´»è·ƒè¯¾å ‚æ°”æ°›

**æ ¸å¿ƒæµç¨‹**: æ•™å¸ˆå‘å¸ƒé—®é¢˜ â†’ å­¦ç”Ÿå›ç­” â†’ ç­”æ¡ˆä»¥å¼¹å¹•å½¢å¼å±•ç¤º â†’ æ•™å¸ˆç‚¹è¯„/é‡‡çº³

### 1.2 æŠ€æœ¯æ ˆ
- **åç«¯**: Flask-OpenAPI3 + Flask-SocketIO (WebSocket)
- **å‰ç«¯**: Vue 3 + Socket.io + Ant Design Vue
- **å®æ—¶é€šä¿¡**: WebSocket (æˆ¿é—´æœºåˆ¶)
- **æ•°æ®å¯è§†åŒ–**: ECharts

### 1.3 å·²æœ‰æ•°æ®è¡¨
âœ… æ•°æ®è¡¨å·²åˆ›å»ºå®Œæˆï¼ˆåœ¨init_db.pyä¸­ï¼‰ï¼š
- `polls` - æŠ•ç¥¨è¡¨
- `poll_responses` - æŠ•ç¥¨è®°å½•è¡¨
- `questions` - é—®é¢˜è¡¨
- `question_answers` - ç­”æ¡ˆè¡¨
- `barrages` - å¼¹å¹•è¡¨ï¼ˆâ­å·²æ‰©å±•ï¼šæ–°å¢`question_id`å­—æ®µï¼Œæ”¯æŒç­”æ¡ˆå¼¹å¹•å’Œè‡ªç”±å¼¹å¹•ï¼‰

**Barrageè¡¨å­—æ®µè¯´æ˜**:
- `question_id`: å…³è”é—®é¢˜IDï¼ˆå¯é€‰ï¼‰
  - ä¸ºç©ºï¼šè‡ªç”±å¼¹å¹•
  - ä¸ä¸ºç©ºï¼šç­”æ¡ˆå¼¹å¹•ï¼ˆå­¦ç”Ÿå›ç­”é—®é¢˜æ—¶è‡ªåŠ¨ç”Ÿæˆï¼‰

### 1.4 å·²å®Œæˆå·¥ä½œ
âœ… Schemaæ¨¡å‹å·²åˆ›å»ºå®Œæˆï¼š`backend/app/schemas/interaction_schemas.py`
âœ… æ•°æ®åº“æ¨¡å‹å·²æ›´æ–°ï¼š`backend/app/models/interaction.py` - Barrageæ¨¡å‹æ–°å¢question_idå­—æ®µ

### 1.5 æ ¸å¿ƒä¸šåŠ¡æµç¨‹è¯¦è§£

#### æµç¨‹1: æŠ•ç¥¨äº’åŠ¨
```
1. æ•™å¸ˆåˆ›å»ºæŠ•ç¥¨
   â”œâ”€â”€ è¾“å…¥æ ‡é¢˜ã€æè¿°
   â”œâ”€â”€ è®¾ç½®é€‰é¡¹ï¼ˆå•é€‰/å¤šé€‰ï¼‰
   â”œâ”€â”€ è®¾ç½®æ—¶é—´èŒƒå›´
   â””â”€â”€ å‘å¸ƒæŠ•ç¥¨
   
2. WebSocketæ¨é€é€šçŸ¥
   â””â”€â”€ æ‰€æœ‰åœ¨çº¿å­¦ç”Ÿæ”¶åˆ°æ–°æŠ•ç¥¨é€šçŸ¥
   
3. å­¦ç”Ÿå‚ä¸æŠ•ç¥¨
   â”œâ”€â”€ æŸ¥çœ‹æŠ•ç¥¨è¯¦æƒ…
   â”œâ”€â”€ é€‰æ‹©é€‰é¡¹
   â””â”€â”€ æäº¤æŠ•ç¥¨
   
4. å®æ—¶ç»Ÿè®¡å±•ç¤º
   â”œâ”€â”€ æ¯æ¬¡æŠ•ç¥¨åæ›´æ–°ç»Ÿè®¡
   â”œâ”€â”€ WebSocketæ¨é€ç»“æœç»™æ•™å¸ˆ
   â””â”€â”€ å›¾è¡¨å®æ—¶æ›´æ–°
```

#### æµç¨‹2: æé—®ç­”æ¡ˆå¼¹å¹•å±•ç¤º â­ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
```
1. æ•™å¸ˆå‘å¸ƒé—®é¢˜
   â”œâ”€â”€ è¾“å…¥é—®é¢˜å†…å®¹
   â”œâ”€â”€ é€‰æ‹©è¯¾ç¨‹
   â””â”€â”€ å‘å¸ƒé—®é¢˜
   
2. WebSocketæ¨é€é—®é¢˜
   â””â”€â”€ æ‰€æœ‰åœ¨çº¿å­¦ç”Ÿæ”¶åˆ°æ–°é—®é¢˜é€šçŸ¥
   
3. å­¦ç”Ÿå›ç­”é—®é¢˜
   â”œâ”€â”€ è¾“å…¥ç­”æ¡ˆå†…å®¹
   â”œâ”€â”€ æäº¤ç­”æ¡ˆ
   â””â”€â”€ ç­”æ¡ˆä¿å­˜åˆ° question_answers è¡¨
   
4. ç­”æ¡ˆè‡ªåŠ¨è½¬ä¸ºå¼¹å¹• â­
   â”œâ”€â”€ åç«¯æ¥æ”¶ç­”æ¡ˆå
   â”œâ”€â”€ åŒæ—¶åˆ›å»ºå¼¹å¹•è®°å½•ï¼ˆbarragesè¡¨ï¼‰
   â”œâ”€â”€ WebSocketå¹¿æ’­å¼¹å¹•
   â””â”€â”€ å‰ç«¯å¼¹å¹•å¢™å®æ—¶æ»šåŠ¨å±•ç¤º
   
5. æ•™å¸ˆæ“ä½œ
   â”œâ”€â”€ å®æ—¶çœ‹åˆ°å­¦ç”Ÿç­”æ¡ˆå¼¹å¹•
   â”œâ”€â”€ å¯ä»¥ç‚¹è¯„ç­”æ¡ˆ
   â”œâ”€â”€ å¯ä»¥é‡‡çº³ä¼˜ç§€ç­”æ¡ˆ
   â””â”€â”€ å¯ä»¥åˆ é™¤ä¸å½“å¼¹å¹•
```

#### æµç¨‹3: è‡ªç”±å¼¹å¹•
```
1. ç”¨æˆ·å‘é€å¼¹å¹•
   â”œâ”€â”€ è¾“å…¥å¼¹å¹•å†…å®¹
   â”œâ”€â”€ æ•æ„Ÿè¯è¿‡æ»¤
   â””â”€â”€ æäº¤å¼¹å¹•
   
2. WebSocketå¹¿æ’­
   â””â”€â”€ å®æ—¶æ¨é€ç»™æ‰€æœ‰åœ¨çº¿ç”¨æˆ·
   
3. å¼¹å¹•å¢™å±•ç¤º
   â””â”€â”€ æ»šåŠ¨å±•ç¤ºå¼¹å¹•
```

**å…³é”®ç‚¹**: 
- é—®é¢˜ç­”æ¡ˆä¼š**è‡ªåŠ¨ç”Ÿæˆå¼¹å¹•**ï¼Œå®ç°ç­”æ¡ˆçš„å®æ—¶å¯è§†åŒ–å±•ç¤º
- å¼¹å¹•è¡¨ï¼ˆbarragesï¼‰æ—¢å­˜å‚¨è‡ªç”±å¼¹å¹•ï¼Œä¹Ÿå­˜å‚¨é—®é¢˜ç­”æ¡ˆå¼¹å¹•
- å¯ä»¥é€šè¿‡ `question_id` å­—æ®µåŒºåˆ†æ˜¯ç­”æ¡ˆå¼¹å¹•è¿˜æ˜¯è‡ªç”±å¼¹å¹•

---

## äºŒã€å¼€å‘æµç¨‹æ€»è§ˆ

```
é˜¶æ®µ1: åç«¯å¼€å‘ (3-4å¤©)
â”œâ”€â”€ âœ… 1. åˆ›å»ºSchemaæ¨¡å‹ (å·²å®Œæˆ)
â”œâ”€â”€ 2. ç¼–å†™Serviceå±‚ (1å¤©)
â”œâ”€â”€ 3. å¼€å‘APIæ¥å£ (1å¤©)
â””â”€â”€ 4. WebSocketé›†æˆ (1-1.5å¤©)

é˜¶æ®µ2: å‰ç«¯å¼€å‘ (3-4å¤©)
â”œâ”€â”€ 1. APIæ¥å£å°è£… (0.5å¤©)
â”œâ”€â”€ 2. é¡µé¢ç»„ä»¶å¼€å‘ (2å¤©)
â”œâ”€â”€ 3. WebSocketé›†æˆ (1å¤©)
â””â”€â”€ 4. æ•°æ®å¯è§†åŒ– (0.5å¤©)

é˜¶æ®µ3: æµ‹è¯•ä¸ä¼˜åŒ– (1-2å¤©)
â”œâ”€â”€ 1. åŠŸèƒ½æµ‹è¯•
â”œâ”€â”€ 2. å¹¶å‘æµ‹è¯•
â””â”€â”€ 3. æ€§èƒ½ä¼˜åŒ–
```

---

## ä¸‰ã€é˜¶æ®µ1: åç«¯å¼€å‘

### æ­¥éª¤2: ç¼–å†™Serviceå±‚ (1å¤©)

#### 2.1 æŠ•ç¥¨æœåŠ¡ - `backend/app/services/poll_service.py`

```python
"""
æŠ•ç¥¨æœåŠ¡å±‚
å¤„ç†æŠ•ç¥¨ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
"""
from typing import List, Optional, Dict, Any
from app.models.interaction import Poll, PollResponse
from app.models.user import User
from app.models.course import Course
from app.extensions import db
from app.schemas.interaction_schemas import PollCreateModel, PollUpdateModel
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class PollService:
    """æŠ•ç¥¨ä¸šåŠ¡é€»è¾‘æœåŠ¡"""
    
    @staticmethod
    def create_poll(teacher_id: int, poll_data: PollCreateModel) -> Poll:
        """
        åˆ›å»ºæŠ•ç¥¨
        
        Args:
            teacher_id: æ•™å¸ˆID
            poll_data: æŠ•ç¥¨æ•°æ®
            
        Returns:
            åˆ›å»ºçš„æŠ•ç¥¨å¯¹è±¡
        """
        # éªŒè¯è¯¾ç¨‹æ˜¯å¦å­˜åœ¨
        course = Course.query.get(poll_data.course_id)
        if not course:
            raise ValueError("è¯¾ç¨‹ä¸å­˜åœ¨")
        
        # åˆ›å»ºæŠ•ç¥¨
        poll = Poll(
            title=poll_data.title,
            description=poll_data.description,
            course_id=poll_data.course_id,
            teacher_id=teacher_id,
            poll_type=poll_data.poll_type.value,
            options=poll_data.options,
            is_anonymous=poll_data.is_anonymous,
            start_time=poll_data.start_time,
            end_time=poll_data.end_time,
            status='active'
        )
        
        try:
            db.session.add(poll)
            db.session.commit()
            logger.info(f"Poll created: {poll.id} by teacher {teacher_id}")
            return poll
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating poll: {str(e)}")
            raise
    
    @staticmethod
    def get_poll_by_id(poll_id: int) -> Optional[Poll]:
        """æ ¹æ®IDè·å–æŠ•ç¥¨"""
        return Poll.query.get(poll_id)
    
    @staticmethod
    def get_polls_by_course(course_id: int, page: int = 1, per_page: int = 20) -> tuple:
        """
        è·å–è¯¾ç¨‹çš„æŠ•ç¥¨åˆ—è¡¨
        
        Returns:
            (æŠ•ç¥¨åˆ—è¡¨, æ€»æ•°)
        """
        query = Poll.query.filter_by(course_id=course_id).order_by(Poll.created_at.desc())
        
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)
        
        return pagination.items, pagination.total
    
    @staticmethod
    def update_poll(poll_id: int, poll_data: PollUpdateModel) -> Optional[Poll]:
        """æ›´æ–°æŠ•ç¥¨"""
        poll = Poll.query.get(poll_id)
        if not poll:
            return None
        
        # æ›´æ–°å­—æ®µ
        if poll_data.title is not None:
            poll.title = poll_data.title
        if poll_data.description is not None:
            poll.description = poll_data.description
        if poll_data.end_time is not None:
            poll.end_time = poll_data.end_time
        if poll_data.status is not None:
            poll.status = poll_data.status.value
        
        try:
            db.session.commit()
            logger.info(f"Poll updated: {poll_id}")
            return poll
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error updating poll: {str(e)}")
            raise
    
    @staticmethod
    def delete_poll(poll_id: int) -> bool:
        """åˆ é™¤æŠ•ç¥¨"""
        poll = Poll.query.get(poll_id)
        if not poll:
            return False
        
        try:
            db.session.delete(poll)
            db.session.commit()
            logger.info(f"Poll deleted: {poll_id}")
            return True
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error deleting poll: {str(e)}")
            raise
    
    @staticmethod
    def vote(poll_id: int, student_id: int, selected_options: List[int]) -> PollResponse:
        """
        å­¦ç”ŸæŠ•ç¥¨
        
        Args:
            poll_id: æŠ•ç¥¨ID
            student_id: å­¦ç”ŸID
            selected_options: é€‰ä¸­çš„é€‰é¡¹IDåˆ—è¡¨
            
        Returns:
            æŠ•ç¥¨å“åº”å¯¹è±¡
        """
        # éªŒè¯æŠ•ç¥¨æ˜¯å¦å­˜åœ¨
        poll = Poll.query.get(poll_id)
        if not poll:
            raise ValueError("æŠ•ç¥¨ä¸å­˜åœ¨")
        
        # æ£€æŸ¥æŠ•ç¥¨çŠ¶æ€
        if poll.status != 'active':
            raise ValueError("æŠ•ç¥¨å·²ç»“æŸ")
        
        # æ£€æŸ¥æ—¶é—´
        now = datetime.utcnow()
        if now < poll.start_time or now > poll.end_time:
            raise ValueError("ä¸åœ¨æŠ•ç¥¨æ—¶é—´èŒƒå›´å†…")
        
        # æ£€æŸ¥æ˜¯å¦å·²æŠ•ç¥¨
        existing_response = PollResponse.query.filter_by(
            poll_id=poll_id,
            student_id=student_id
        ).first()
        
        if existing_response:
            raise ValueError("æ‚¨å·²ç»æŠ•è¿‡ç¥¨äº†")
        
        # éªŒè¯é€‰é¡¹
        if poll.poll_type == 'single' and len(selected_options) != 1:
            raise ValueError("å•é€‰æŠ•ç¥¨åªèƒ½é€‰æ‹©ä¸€ä¸ªé€‰é¡¹")
        
        # åˆ›å»ºæŠ•ç¥¨å“åº”
        response = PollResponse(
            poll_id=poll_id,
            student_id=student_id,
            selected_options=selected_options
        )
        
        try:
            db.session.add(response)
            db.session.commit()
            logger.info(f"Vote recorded: poll {poll_id}, student {student_id}")
            return response
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error recording vote: {str(e)}")
            raise
    
    @staticmethod
    def get_poll_results(poll_id: int) -> Dict[str, Any]:
        """
        è·å–æŠ•ç¥¨ç»“æœç»Ÿè®¡
        
        Returns:
            {
                'total_votes': 100,
                'option_stats': [
                    {'option_id': 1, 'count': 30, 'percentage': 30.0},
                    ...
                ]
            }
        """
        poll = Poll.query.get(poll_id)
        if not poll:
            raise ValueError("æŠ•ç¥¨ä¸å­˜åœ¨")
        
        # è·å–æ‰€æœ‰æŠ•ç¥¨å“åº”
        responses = PollResponse.query.filter_by(poll_id=poll_id).all()
        total_votes = len(responses)
        
        # ç»Ÿè®¡æ¯ä¸ªé€‰é¡¹çš„ç¥¨æ•°
        option_counts = {}
        for response in responses:
            for option_id in response.selected_options:
                option_counts[option_id] = option_counts.get(option_id, 0) + 1
        
        # è®¡ç®—ç™¾åˆ†æ¯”
        option_stats = []
        for option in poll.options:
            option_id = option['id']
            count = option_counts.get(option_id, 0)
            percentage = (count / total_votes * 100) if total_votes > 0 else 0
            
            option_stats.append({
                'option_id': option_id,
                'option_text': option['text'],
                'count': count,
                'percentage': round(percentage, 2)
            })
        
        return {
            'total_votes': total_votes,
            'option_stats': option_stats
        }
```

#### 2.2 æé—®æœåŠ¡ - `backend/app/services/question_service.py`

```python
"""
æé—®æœåŠ¡å±‚
å¤„ç†æé—®å’Œå›ç­”ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
"""
from typing import List, Optional
from app.models.interaction import Question, QuestionAnswer
from app.models.user import User
from app.models.course import Course
from app.extensions import db
from app.schemas.interaction_schemas import (
    QuestionCreateModel, QuestionUpdateModel,
    QuestionAnswerCreateModel, QuestionAnswerUpdateModel
)
import logging

logger = logging.getLogger(__name__)


class QuestionService:
    """æé—®ä¸šåŠ¡é€»è¾‘æœåŠ¡"""
    
    @staticmethod
    def create_question(user_id: int, question_data: QuestionCreateModel) -> Question:
        """åˆ›å»ºé—®é¢˜"""
        # éªŒè¯è¯¾ç¨‹æ˜¯å¦å­˜åœ¨
        course = Course.query.get(question_data.course_id)
        if not course:
            raise ValueError("è¯¾ç¨‹ä¸å­˜åœ¨")
        
        question = Question(
            content=question_data.content,
            course_id=question_data.course_id,
            user_id=user_id,
            is_anonymous=question_data.is_anonymous,
            status='pending',
            like_count=0
        )
        
        try:
            db.session.add(question)
            db.session.commit()
            logger.info(f"Question created: {question.id} by user {user_id}")
            return question
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating question: {str(e)}")
            raise
    
    @staticmethod
    def get_question_by_id(question_id: int) -> Optional[Question]:
        """æ ¹æ®IDè·å–é—®é¢˜"""
        return Question.query.get(question_id)
    
    @staticmethod
    def get_questions_by_course(course_id: int, page: int = 1, per_page: int = 20) -> tuple:
        """è·å–è¯¾ç¨‹çš„é—®é¢˜åˆ—è¡¨"""
        query = Question.query.filter_by(course_id=course_id).order_by(Question.created_at.desc())
        
        pagination = query.paginate(page=page, per_page=per_page, error_out=False)
        
        return pagination.items, pagination.total
    
    @staticmethod
    def update_question(question_id: int, question_data: QuestionUpdateModel) -> Optional[Question]:
        """æ›´æ–°é—®é¢˜"""
        question = Question.query.get(question_id)
        if not question:
            return None
        
        if question_data.content is not None:
            question.content = question_data.content
        if question_data.status is not None:
            question.status = question_data.status.value
        
        try:
            db.session.commit()
            logger.info(f"Question updated: {question_id}")
            return question
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error updating question: {str(e)}")
            raise
    
    @staticmethod
    def delete_question(question_id: int) -> bool:
        """åˆ é™¤é—®é¢˜"""
        question = Question.query.get(question_id)
        if not question:
            return False
        
        try:
            db.session.delete(question)
            db.session.commit()
            logger.info(f"Question deleted: {question_id}")
            return True
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error deleting question: {str(e)}")
            raise
    
    @staticmethod
    def create_answer(question_id: int, user_id: int, answer_data: QuestionAnswerCreateModel) -> QuestionAnswer:
        """åˆ›å»ºå›ç­”"""
        # éªŒè¯é—®é¢˜æ˜¯å¦å­˜åœ¨
        question = Question.query.get(question_id)
        if not question:
            raise ValueError("é—®é¢˜ä¸å­˜åœ¨")
        
        answer = QuestionAnswer(
            question_id=question_id,
            user_id=user_id,
            content=answer_data.content,
            is_accepted=False,
            like_count=0
        )
        
        try:
            db.session.add(answer)
            # æ›´æ–°é—®é¢˜çŠ¶æ€
            question.status = 'answered'
            db.session.commit()
            logger.info(f"Answer created: {answer.id} for question {question_id}")
            return answer
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating answer: {str(e)}")
            raise
    
    @staticmethod
    def get_answers_by_question(question_id: int) -> List[QuestionAnswer]:
        """è·å–é—®é¢˜çš„æ‰€æœ‰å›ç­”"""
        return QuestionAnswer.query.filter_by(question_id=question_id).order_by(
            QuestionAnswer.is_accepted.desc(),
            QuestionAnswer.like_count.desc(),
            QuestionAnswer.created_at.desc()
        ).all()
    
    @staticmethod
    def accept_answer(answer_id: int) -> Optional[QuestionAnswer]:
        """é‡‡çº³ç­”æ¡ˆ"""
        answer = QuestionAnswer.query.get(answer_id)
        if not answer:
            return None
        
        # å–æ¶ˆåŒä¸€é—®é¢˜ä¸‹å…¶ä»–ç­”æ¡ˆçš„é‡‡çº³çŠ¶æ€
        QuestionAnswer.query.filter_by(
            question_id=answer.question_id,
            is_accepted=True
        ).update({'is_accepted': False})
        
        # è®¾ç½®å½“å‰ç­”æ¡ˆä¸ºé‡‡çº³
        answer.is_accepted = True
        
        try:
            db.session.commit()
            logger.info(f"Answer accepted: {answer_id}")
            return answer
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error accepting answer: {str(e)}")
            raise
    
    @staticmethod
    def like_question(question_id: int) -> Optional[Question]:
        """ç‚¹èµé—®é¢˜"""
        question = Question.query.get(question_id)
        if not question:
            return None
        
        question.like_count += 1
        
        try:
            db.session.commit()
            return question
        except Exception as e:
            db.session.rollback()
            raise
    
    @staticmethod
    def like_answer(answer_id: int) -> Optional[QuestionAnswer]:
        """ç‚¹èµå›ç­”"""
        answer = QuestionAnswer.query.get(answer_id)
        if not answer:
            return None
        
        answer.like_count += 1
        
        try:
            db.session.commit()
            return answer
        except Exception as e:
            db.session.rollback()
            raise
```

#### 2.3 å¼¹å¹•æœåŠ¡ - `backend/app/services/barrage_service.py`

```python
"""
å¼¹å¹•æœåŠ¡å±‚
å¤„ç†å¼¹å¹•ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
"""
from typing import List, Optional
from app.models.interaction import Barrage
from app.models.course import Course
from app.extensions import db
from app.schemas.interaction_schemas import BarrageCreateModel
import logging
import re

logger = logging.getLogger(__name__)


class BarrageService:
    """å¼¹å¹•ä¸šåŠ¡é€»è¾‘æœåŠ¡"""
    
    # æ•æ„Ÿè¯åˆ—è¡¨ï¼ˆç¤ºä¾‹ï¼‰
    SENSITIVE_WORDS = ['æ•æ„Ÿè¯1', 'æ•æ„Ÿè¯2', 'è¿ç¦è¯']
    
    @staticmethod
    def filter_sensitive_words(content: str) -> str:
        """
        æ•æ„Ÿè¯è¿‡æ»¤
        
        Args:
            content: åŸå§‹å†…å®¹
            
        Returns:
            è¿‡æ»¤åçš„å†…å®¹
        """
        filtered_content = content
        for word in BarrageService.SENSITIVE_WORDS:
            if word in filtered_content:
                filtered_content = filtered_content.replace(word, '*' * len(word))
        
        return filtered_content
    
    @staticmethod
    def create_barrage(user_id: int, barrage_data: BarrageCreateModel) -> Barrage:
        """åˆ›å»ºå¼¹å¹•"""
        # éªŒè¯è¯¾ç¨‹æ˜¯å¦å­˜åœ¨
        course = Course.query.get(barrage_data.course_id)
        if not course:
            raise ValueError("è¯¾ç¨‹ä¸å­˜åœ¨")
        
        # æ•æ„Ÿè¯è¿‡æ»¤
        filtered_content = BarrageService.filter_sensitive_words(barrage_data.content)
        
        barrage = Barrage(
            content=filtered_content,
            course_id=barrage_data.course_id,
            user_id=user_id,
            is_anonymous=barrage_data.is_anonymous,
            status=True
        )
        
        try:
            db.session.add(barrage)
            db.session.commit()
            logger.info(f"Barrage created: {barrage.id} by user {user_id}")
            return barrage
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error creating barrage: {str(e)}")
            raise
    
    @staticmethod
    def get_barrages_by_course(course_id: int, limit: int = 100) -> List[Barrage]:
        """
        è·å–è¯¾ç¨‹çš„å¼¹å¹•åˆ—è¡¨ï¼ˆæœ€è¿‘çš„Næ¡ï¼‰
        
        Args:
            course_id: è¯¾ç¨‹ID
            limit: è¿”å›æ•°é‡é™åˆ¶
        """
        return Barrage.query.filter_by(
            course_id=course_id,
            status=True
        ).order_by(Barrage.created_at.desc()).limit(limit).all()
    
    @staticmethod
    def delete_barrage(barrage_id: int) -> bool:
        """åˆ é™¤å¼¹å¹•ï¼ˆè½¯åˆ é™¤ï¼‰"""
        barrage = Barrage.query.get(barrage_id)
        if not barrage:
            return False
        
        barrage.status = False
        
        try:
            db.session.commit()
            logger.info(f"Barrage deleted: {barrage_id}")
            return True
        except Exception as e:
            db.session.rollback()
            logger.error(f"Error deleting barrage: {str(e)}")
            raise
```

### æ­¥éª¤3: å¼€å‘APIæ¥å£ (1å¤©)

#### 3.1 æŠ•ç¥¨API - `backend/app/api/poll_api.py`

```python
"""
æŠ•ç¥¨API
æä¾›æŠ•ç¥¨ç›¸å…³çš„RESTfulæ¥å£
"""
from flask_openapi3 import APIBlueprint, Tag
from app.schemas.interaction_schemas import (
    PollCreateModel, PollUpdateModel, PollResponseModel,
    PollDetailResponseModel, PollListResponseModel, PollPathModel,
    PollVoteModel, PollResponseResponseModel
)
from app.schemas.common_schemas import MessageResponseModel, QueryModel
from app.services.poll_service import PollService
from app.utils.auth_decorators import login_required, get_current_user
from app.utils.response_handler import ResponseHandler
import logging

logger = logging.getLogger(__name__)

poll_api_bp = APIBlueprint('poll_api', __name__, url_prefix='/api/v1/polls')
poll_tag = Tag(name="PollController", description="æŠ•ç¥¨ç®¡ç†API")


class PollAPI:
    """æŠ•ç¥¨APIç±» - è£…é¥°å™¨æ–¹å¼"""
    
    @staticmethod
    @poll_api_bp.post('/', summary="åˆ›å»ºæŠ•ç¥¨", tags=[poll_tag])
    @login_required
    def create_poll(body: PollCreateModel):
        """åˆ›å»ºæŠ•ç¥¨ï¼ˆæ•™å¸ˆï¼‰"""
        try:
            current_user = get_current_user()
            
            # éªŒè¯æƒé™ï¼ˆåªæœ‰æ•™å¸ˆå¯ä»¥åˆ›å»ºæŠ•ç¥¨ï¼‰
            if not current_user.is_teacher():
                return ResponseHandler.error(
                    message="åªæœ‰æ•™å¸ˆå¯ä»¥åˆ›å»ºæŠ•ç¥¨",
                    error_code="PERMISSION_DENIED"
                ), 403
            
            poll = PollService.create_poll(current_user.id, body)
            
            return ResponseHandler.success(
                data=poll.to_dict(),
                message="æŠ•ç¥¨åˆ›å»ºæˆåŠŸ"
            ), 201
            
        except ValueError as e:
            return ResponseHandler.error(str(e), "VALIDATION_ERROR"), 400
        except Exception as e:
            logger.error(f"Error creating poll: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.get('/', summary="è·å–æŠ•ç¥¨åˆ—è¡¨", tags=[poll_tag])
    @login_required
    def list_polls(query: QueryModel):
        """è·å–æŠ•ç¥¨åˆ—è¡¨"""
        try:
            # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥æ ¹æ®ç”¨æˆ·è§’è‰²è¿‡æ»¤è¯¾ç¨‹
            course_id = query.course_id if hasattr(query, 'course_id') else None
            
            if not course_id:
                return ResponseHandler.error("ç¼ºå°‘è¯¾ç¨‹IDå‚æ•°", "MISSING_PARAM"), 400
            
            polls, total = PollService.get_polls_by_course(
                course_id,
                page=query.page,
                per_page=query.per_page
            )
            
            poll_list = [poll.to_dict() for poll in polls]
            
            return ResponseHandler.paginated(
                items=poll_list,
                total=total,
                page=query.page,
                per_page=query.per_page,
                message="è·å–æŠ•ç¥¨åˆ—è¡¨æˆåŠŸ"
            ), 200
            
        except Exception as e:
            logger.error(f"Error listing polls: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.get('/<int:poll_id>', summary="è·å–æŠ•ç¥¨è¯¦æƒ…", tags=[poll_tag])
    @login_required
    def get_poll(path: PollPathModel):
        """è·å–æŠ•ç¥¨è¯¦æƒ…"""
        try:
            poll = PollService.get_poll_by_id(path.poll_id)
            
            if not poll:
                return ResponseHandler.error("æŠ•ç¥¨ä¸å­˜åœ¨", "NOT_FOUND"), 404
            
            # è·å–æŠ•ç¥¨ç»“æœ
            results = PollService.get_poll_results(path.poll_id)
            
            poll_data = poll.to_dict()
            poll_data['results'] = results
            
            return ResponseHandler.success(data=poll_data), 200
            
        except Exception as e:
            logger.error(f"Error getting poll: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.put('/<int:poll_id>', summary="æ›´æ–°æŠ•ç¥¨", tags=[poll_tag])
    @login_required
    def update_poll(path: PollPathModel, body: PollUpdateModel):
        """æ›´æ–°æŠ•ç¥¨ï¼ˆæ•™å¸ˆï¼‰"""
        try:
            current_user = get_current_user()
            
            poll = PollService.get_poll_by_id(path.poll_id)
            if not poll:
                return ResponseHandler.error("æŠ•ç¥¨ä¸å­˜åœ¨", "NOT_FOUND"), 404
            
            # éªŒè¯æƒé™
            if poll.teacher_id != current_user.id and not current_user.is_admin():
                return ResponseHandler.error("æ— æƒé™ä¿®æ”¹æ­¤æŠ•ç¥¨", "PERMISSION_DENIED"), 403
            
            updated_poll = PollService.update_poll(path.poll_id, body)
            
            return ResponseHandler.success(
                data=updated_poll.to_dict(),
                message="æŠ•ç¥¨æ›´æ–°æˆåŠŸ"
            ), 200
            
        except ValueError as e:
            return ResponseHandler.error(str(e), "VALIDATION_ERROR"), 400
        except Exception as e:
            logger.error(f"Error updating poll: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.delete('/<int:poll_id>', summary="åˆ é™¤æŠ•ç¥¨", tags=[poll_tag])
    @login_required
    def delete_poll(path: PollPathModel):
        """åˆ é™¤æŠ•ç¥¨ï¼ˆæ•™å¸ˆï¼‰"""
        try:
            current_user = get_current_user()
            
            poll = PollService.get_poll_by_id(path.poll_id)
            if not poll:
                return ResponseHandler.error("æŠ•ç¥¨ä¸å­˜åœ¨", "NOT_FOUND"), 404
            
            # éªŒè¯æƒé™
            if poll.teacher_id != current_user.id and not current_user.is_admin():
                return ResponseHandler.error("æ— æƒé™åˆ é™¤æ­¤æŠ•ç¥¨", "PERMISSION_DENIED"), 403
            
            PollService.delete_poll(path.poll_id)
            
            return ResponseHandler.success(message="æŠ•ç¥¨åˆ é™¤æˆåŠŸ"), 200
            
        except Exception as e:
            logger.error(f"Error deleting poll: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.post('/<int:poll_id>/vote', summary="å­¦ç”ŸæŠ•ç¥¨", tags=[poll_tag])
    @login_required
    def vote(path: PollPathModel, body: PollVoteModel):
        """å­¦ç”ŸæŠ•ç¥¨"""
        try:
            current_user = get_current_user()
            
            # éªŒè¯æƒé™ï¼ˆåªæœ‰å­¦ç”Ÿå¯ä»¥æŠ•ç¥¨ï¼‰
            if not current_user.is_student():
                return ResponseHandler.error("åªæœ‰å­¦ç”Ÿå¯ä»¥æŠ•ç¥¨", "PERMISSION_DENIED"), 403
            
            response = PollService.vote(
                path.poll_id,
                current_user.id,
                body.selected_options
            )
            
            return ResponseHandler.success(
                data=response.to_dict(),
                message="æŠ•ç¥¨æˆåŠŸ"
            ), 201
            
        except ValueError as e:
            return ResponseHandler.error(str(e), "VALIDATION_ERROR"), 400
        except Exception as e:
            logger.error(f"Error voting: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
    
    @staticmethod
    @poll_api_bp.get('/<int:poll_id>/results', summary="è·å–æŠ•ç¥¨ç»“æœ", tags=[poll_tag])
    @login_required
    def get_results(path: PollPathModel):
        """è·å–æŠ•ç¥¨ç»“æœç»Ÿè®¡"""
        try:
            poll = PollService.get_poll_by_id(path.poll_id)
            if not poll:
                return ResponseHandler.error("æŠ•ç¥¨ä¸å­˜åœ¨", "NOT_FOUND"), 404
            
            results = PollService.get_poll_results(path.poll_id)
            
            return ResponseHandler.success(data=results), 200
            
        except Exception as e:
            logger.error(f"Error getting poll results: {str(e)}")
            return ResponseHandler.error("æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", "INTERNAL_ERROR"), 500
```

**æç¤º**: ç±»ä¼¼çš„æ–¹å¼åˆ›å»º `question_api.py` å’Œ `barrage_api.py`

### æ­¥éª¤4: WebSocketé›†æˆ (1-1.5å¤©)

#### 4.1 å®‰è£…ä¾èµ–

```bash
pip install flask-socketio python-socketio
```

#### 4.2 åˆ›å»ºWebSocketå¤„ç†å™¨ - `backend/app/websocket/interaction_events.py`

```python
"""
è¯¾å ‚äº’åŠ¨WebSocketäº‹ä»¶å¤„ç†
"""
from flask_socketio import emit, join_room, leave_room
from flask import request
from app.extensions import socketio
from app.models.user import User
import logging

logger = logging.getLogger(__name__)


@socketio.on('connect')
def handle_connect():
    """å®¢æˆ·ç«¯è¿æ¥"""
    logger.info(f"Client connected: {request.sid}")
    emit('connected', {'message': 'è¿æ¥æˆåŠŸ'})


@socketio.on('disconnect')
def handle_disconnect():
    """å®¢æˆ·ç«¯æ–­å¼€è¿æ¥"""
    logger.info(f"Client disconnected: {request.sid}")


@socketio.on('join_course')
def handle_join_course(data):
    """åŠ å…¥è¯¾ç¨‹æˆ¿é—´"""
    course_id = data.get('course_id')
    user_id = data.get('user_id')
    
    if not course_id:
        emit('error', {'message': 'ç¼ºå°‘è¯¾ç¨‹ID'})
        return
    
    room = f'course_{course_id}'
    join_room(room)
    
    logger.info(f"User {user_id} joined course room: {room}")
    emit('joined_course', {
        'message': f'å·²åŠ å…¥è¯¾ç¨‹ {course_id}',
        'room': room
    })


@socketio.on('leave_course')
def handle_leave_course(data):
    """ç¦»å¼€è¯¾ç¨‹æˆ¿é—´"""
    course_id = data.get('course_id')
    user_id = data.get('user_id')
    
    if not course_id:
        emit('error', {'message': 'ç¼ºå°‘è¯¾ç¨‹ID'})
        return
    
    room = f'course_{course_id}'
    leave_room(room)
    
    logger.info(f"User {user_id} left course room: {room}")
    emit('left_course', {
        'message': f'å·²ç¦»å¼€è¯¾ç¨‹ {course_id}',
        'room': room
    })


@socketio.on('poll_created')
def handle_poll_created(data):
    """æŠ•ç¥¨åˆ›å»ºé€šçŸ¥"""
    course_id = data.get('course_id')
    poll_data = data.get('poll')
    
    room = f'course_{course_id}'
    
    # å¹¿æ’­ç»™æˆ¿é—´å†…æ‰€æœ‰ç”¨æˆ·
    emit('new_poll', {
        'message': 'æ–°æŠ•ç¥¨å·²åˆ›å»º',
        'poll': poll_data
    }, room=room)
    
    logger.info(f"Poll created notification sent to room: {room}")


@socketio.on('poll_voted')
def handle_poll_voted(data):
    """æŠ•ç¥¨å“åº”é€šçŸ¥"""
    course_id = data.get('course_id')
    poll_id = data.get('poll_id')
    results = data.get('results')
    
    room = f'course_{course_id}'
    
    # å®æ—¶æ¨é€æŠ•ç¥¨ç»“æœç»™æ•™å¸ˆç«¯
    emit('poll_results_updated', {
        'poll_id': poll_id,
        'results': results
    }, room=room)
    
    logger.info(f"Poll results updated for poll {poll_id} in room: {room}")


@socketio.on('question_created')
def handle_question_created(data):
    """æé—®åˆ›å»ºé€šçŸ¥"""
    course_id = data.get('course_id')
    question_data = data.get('question')
    
    room = f'course_{course_id}'
    
    emit('new_question', {
        'message': 'æ–°é—®é¢˜å·²æäº¤',
        'question': question_data
    }, room=room)
    
    logger.info(f"Question created notification sent to room: {room}")


@socketio.on('answer_submitted')
def handle_answer_submitted(data):
    """å›ç­”æäº¤é€šçŸ¥"""
    course_id = data.get('course_id')
    question_id = data.get('question_id')
    answer_data = data.get('answer')
    
    room = f'course_{course_id}'
    
    emit('new_answer', {
        'question_id': question_id,
        'answer': answer_data
    }, room=room)
    
    logger.info(f"Answer submitted for question {question_id} in room: {room}")


@socketio.on('barrage_sent')
def handle_barrage_sent(data):
    """å¼¹å¹•å‘é€"""
    course_id = data.get('course_id')
    barrage_data = data.get('barrage')
    
    room = f'course_{course_id}'
    
    # å¹¿æ’­å¼¹å¹•ç»™æ‰€æœ‰åœ¨çº¿ç”¨æˆ·
    emit('new_barrage', {
        'barrage': barrage_data
    }, room=room, include_self=False)
    
    logger.info(f"Barrage sent in room: {room}")
```

#### 4.3 åˆå§‹åŒ–SocketIO - ä¿®æ”¹ `backend/app/__init__.py`

```python
# åœ¨ create_app å‡½æ•°ä¸­æ·»åŠ 
from app.extensions import socketio

def create_app(config_name='development'):
    # ... ç°æœ‰ä»£ç  ...
    
    # åˆå§‹åŒ–SocketIO
    socketio.init_app(app, cors_allowed_origins="*")
    
    # æ³¨å†ŒWebSocketäº‹ä»¶
    from app.websocket import interaction_events
    
    return app
```

#### 4.4 ä¿®æ”¹ `backend/app/extensions.py`

```python
from flask_socketio import SocketIO

# æ·»åŠ SocketIOå®ä¾‹
socketio = SocketIO()
```

#### 4.5 ä¿®æ”¹å¯åŠ¨æ–‡ä»¶ `backend/run.py`

```python
from app import create_app
from app.extensions import socketio

app = create_app()

if __name__ == '__main__':
    # ä½¿ç”¨socketio.runä»£æ›¿app.run
    socketio.run(app, host='0.0.0.0', port=5030, debug=True)
```

---

## å››ã€é˜¶æ®µ2: å‰ç«¯å¼€å‘

### æ­¥éª¤1: APIæ¥å£å°è£… (0.5å¤©)

#### æ–‡ä»¶: `frontend/src/api/interactionController.ts`

```typescript
import request from '@/utils/request'

/**
 * æŠ•ç¥¨ç›¸å…³API
 */
export const pollApi = {
  // åˆ›å»ºæŠ•ç¥¨
  createPoll: (data: any) => {
    return request.post('/api/v1/polls', data)
  },
  
  // è·å–æŠ•ç¥¨åˆ—è¡¨
  getPollList: (params: any) => {
    return request.get('/api/v1/polls', { params })
  },
  
  // è·å–æŠ•ç¥¨è¯¦æƒ…
  getPollDetail: (pollId: number) => {
    return request.get(`/api/v1/polls/${pollId}`)
  },
  
  // æ›´æ–°æŠ•ç¥¨
  updatePoll: (pollId: number, data: any) => {
    return request.put(`/api/v1/polls/${pollId}`, data)
  },
  
  // åˆ é™¤æŠ•ç¥¨
  deletePoll: (pollId: number) => {
    return request.delete(`/api/v1/polls/${pollId}`)
  },
  
  // å­¦ç”ŸæŠ•ç¥¨
  vote: (pollId: number, data: any) => {
    return request.post(`/api/v1/polls/${pollId}/vote`, data)
  },
  
  // è·å–æŠ•ç¥¨ç»“æœ
  getPollResults: (pollId: number) => {
    return request.get(`/api/v1/polls/${pollId}/results`)
  }
}

/**
 * æé—®ç›¸å…³API
 */
export const questionApi = {
  // åˆ›å»ºé—®é¢˜
  createQuestion: (data: any) => {
    return request.post('/api/v1/questions', data)
  },
  
  // è·å–é—®é¢˜åˆ—è¡¨
  getQuestionList: (params: any) => {
    return request.get('/api/v1/questions', { params })
  },
  
  // è·å–é—®é¢˜è¯¦æƒ…
  getQuestionDetail: (questionId: number) => {
    return request.get(`/api/v1/questions/${questionId}`)
  },
  
  // å›ç­”é—®é¢˜
  createAnswer: (questionId: number, data: any) => {
    return request.post(`/api/v1/questions/${questionId}/answers`, data)
  },
  
  // é‡‡çº³ç­”æ¡ˆ
  acceptAnswer: (questionId: number, answerId: number) => {
    return request.put(`/api/v1/questions/${questionId}/answers/${answerId}/accept`)
  },
  
  // ç‚¹èµé—®é¢˜
  likeQuestion: (questionId: number) => {
    return request.post(`/api/v1/questions/${questionId}/like`)
  }
}

/**
 * å¼¹å¹•ç›¸å…³API
 */
export const barrageApi = {
  // å‘é€å¼¹å¹•
  sendBarrage: (data: any) => {
    return request.post('/api/v1/barrages', data)
  },
  
  // è·å–å¼¹å¹•åˆ—è¡¨
  getBarrageList: (params: any) => {
    return request.get('/api/v1/barrages', { params })
  },
  
  // åˆ é™¤å¼¹å¹•
  deleteBarrage: (barrageId: number) => {
    return request.delete(`/api/v1/barrages/${barrageId}`)
  }
}
```

### æ­¥éª¤2: WebSocketé›†æˆ (1å¤©)

#### æ–‡ä»¶: `frontend/src/utils/socket.ts`

```typescript
import { io, Socket } from 'socket.io-client'

class SocketService {
  private socket: Socket | null = null
  private courseId: number | null = null
  
  /**
   * è¿æ¥WebSocket
   */
  connect() {
    if (this.socket?.connected) {
      return
    }
    
    this.socket = io('http://localhost:5030', {
      transports: ['websocket'],
      autoConnect: true
    })
    
    this.socket.on('connect', () => {
      console.log('WebSocketè¿æ¥æˆåŠŸ')
    })
    
    this.socket.on('disconnect', () => {
      console.log('WebSocketæ–­å¼€è¿æ¥')
    })
    
    this.socket.on('error', (error: any) => {
      console.error('WebSocketé”™è¯¯:', error)
    })
  }
  
  /**
   * æ–­å¼€è¿æ¥
   */
  disconnect() {
    if (this.socket) {
      this.socket.disconnect()
      this.socket = null
    }
  }
  
  /**
   * åŠ å…¥è¯¾ç¨‹æˆ¿é—´
   */
  joinCourse(courseId: number, userId: number) {
    if (!this.socket) {
      this.connect()
    }
    
    this.courseId = courseId
    this.socket?.emit('join_course', { courseId, userId })
  }
  
  /**
   * ç¦»å¼€è¯¾ç¨‹æˆ¿é—´
   */
  leaveCourse(courseId: number, userId: number) {
    this.socket?.emit('leave_course', { courseId, userId })
    this.courseId = null
  }
  
  /**
   * ç›‘å¬æ–°æŠ•ç¥¨
   */
  onNewPoll(callback: (data: any) => void) {
    this.socket?.on('new_poll', callback)
  }
  
  /**
   * ç›‘å¬æŠ•ç¥¨ç»“æœæ›´æ–°
   */
  onPollResultsUpdated(callback: (data: any) => void) {
    this.socket?.on('poll_results_updated', callback)
  }
  
  /**
   * ç›‘å¬æ–°é—®é¢˜
   */
  onNewQuestion(callback: (data: any) => void) {
    this.socket?.on('new_question', callback)
  }
  
  /**
   * ç›‘å¬æ–°å›ç­”
   */
  onNewAnswer(callback: (data: any) => void) {
    this.socket?.on('new_answer', callback)
  }
  
  /**
   * ç›‘å¬æ–°å¼¹å¹•
   */
  onNewBarrage(callback: (data: any) => void) {
    this.socket?.on('new_barrage', callback)
  }
  
  /**
   * å‘é€æŠ•ç¥¨åˆ›å»ºé€šçŸ¥
   */
  emitPollCreated(courseId: number, poll: any) {
    this.socket?.emit('poll_created', { courseId, poll })
  }
  
  /**
   * å‘é€æŠ•ç¥¨å“åº”é€šçŸ¥
   */
  emitPollVoted(courseId: number, pollId: number, results: any) {
    this.socket?.emit('poll_voted', { courseId, pollId, results })
  }
  
  /**
   * å‘é€å¼¹å¹•
   */
  emitBarrage(courseId: number, barrage: any) {
    this.socket?.emit('barrage_sent', { courseId, barrage })
  }
}

export default new SocketService()
```

### æ­¥éª¤3: é¡µé¢ç»„ä»¶å¼€å‘ (2å¤©)

#### 3.1 æŠ•ç¥¨é¡µé¢ - `frontend/src/pages/interaction/PollPage.vue`

```vue
<template>
  <div class="poll-page">
    <a-card title="è¯¾å ‚æŠ•ç¥¨">
      <!-- æ•™å¸ˆç«¯ï¼šåˆ›å»ºæŠ•ç¥¨æŒ‰é’® -->
      <template #extra v-if="isTeacher">
        <a-button type="primary" @click="showCreateModal">
          åˆ›å»ºæŠ•ç¥¨
        </a-button>
      </template>
      
      <!-- æŠ•ç¥¨åˆ—è¡¨ -->
      <a-list
        :data-source="polls"
        :loading="loading"
        :pagination="pagination"
        @change="handlePageChange"
      >
        <template #renderItem="{ item }">
          <a-list-item>
            <a-list-item-meta
              :title="item.title"
              :description="item.description"
            >
              <template #avatar>
                <a-tag :color="item.status === 'active' ? 'green' : 'gray'">
                  {{ item.status === 'active' ? 'è¿›è¡Œä¸­' : 'å·²ç»“æŸ' }}
                </a-tag>
              </template>
            </a-list-item-meta>
            
            <template #actions>
              <a @click="viewPoll(item)">æŸ¥çœ‹</a>
              <a v-if="!item.hasVoted && isStudent" @click="votePoll(item)">æŠ•ç¥¨</a>
              <a v-if="isTeacher" @click="viewResults(item)">ç»“æœ</a>
            </template>
          </a-list-item>
        </template>
      </a-list>
    </a-card>
    
    <!-- åˆ›å»ºæŠ•ç¥¨å¯¹è¯æ¡† -->
    <a-modal
      v-model:visible="createModalVisible"
      title="åˆ›å»ºæŠ•ç¥¨"
      width="600px"
      @ok="handleCreatePoll"
    >
      <a-form :model="pollForm" :rules="pollRules" layout="vertical">
        <a-form-item label="æŠ•ç¥¨æ ‡é¢˜" name="title">
          <a-input v-model:value="pollForm.title" />
        </a-form-item>
        
        <a-form-item label="æŠ•ç¥¨æè¿°" name="description">
          <a-textarea v-model:value="pollForm.description" :rows="3" />
        </a-form-item>
        
        <a-form-item label="æŠ•ç¥¨ç±»å‹" name="pollType">
          <a-radio-group v-model:value="pollForm.pollType">
            <a-radio value="single">å•é€‰</a-radio>
            <a-radio value="multiple">å¤šé€‰</a-radio>
          </a-radio-group>
        </a-form-item>
        
        <a-form-item label="é€‰é¡¹">
          <div v-for="(option, index) in pollForm.options" :key="index" class="option-item">
            <a-input
              v-model:value="option.text"
              :placeholder="`é€‰é¡¹ ${index + 1}`"
              style="width: calc(100% - 40px)"
            />
            <a-button
              type="text"
              danger
              @click="removeOption(index)"
              :disabled="pollForm.options.length <= 2"
            >
              åˆ é™¤
            </a-button>
          </div>
          <a-button type="dashed" block @click="addOption">
            æ·»åŠ é€‰é¡¹
          </a-button>
        </a-form-item>
        
        <a-form-item label="æ—¶é—´èŒƒå›´" name="timeRange">
          <a-range-picker
            v-model:value="pollForm.timeRange"
            show-time
            format="YYYY-MM-DD HH:mm:ss"
            style="width: 100%"
          />
        </a-form-item>
        
        <a-form-item name="isAnonymous">
          <a-checkbox v-model:checked="pollForm.isAnonymous">
            åŒ¿åæŠ•ç¥¨
          </a-checkbox>
        </a-form-item>
      </a-form>
    </a-modal>
    
    <!-- æŠ•ç¥¨å¯¹è¯æ¡† -->
    <a-modal
      v-model:visible="voteModalVisible"
      title="å‚ä¸æŠ•ç¥¨"
      @ok="handleVote"
    >
      <div v-if="currentPoll">
        <h3>{{ currentPoll.title }}</h3>
        <p>{{ currentPoll.description }}</p>
        
        <a-radio-group
          v-if="currentPoll.pollType === 'single'"
          v-model:value="selectedOptions"
        >
          <a-radio
            v-for="option in currentPoll.options"
            :key="option.id"
            :value="option.id"
            style="display: block; margin: 8px 0"
          >
            {{ option.text }}
          </a-radio>
        </a-radio-group>
        
        <a-checkbox-group
          v-else
          v-model:value="selectedOptions"
        >
          <a-checkbox
            v-for="option in currentPoll.options"
            :key="option.id"
            :value="option.id"
            style="display: block; margin: 8px 0"
          >
            {{ option.text }}
          </a-checkbox>
        </a-checkbox-group>
      </div>
    </a-modal>
    
    <!-- ç»“æœå±•ç¤ºå¯¹è¯æ¡† -->
    <a-modal
      v-model:visible="resultsModalVisible"
      title="æŠ•ç¥¨ç»“æœ"
      width="800px"
      :footer="null"
    >
      <div v-if="pollResults">
        <p>æ€»æŠ•ç¥¨æ•°: {{ pollResults.totalVotes }}</p>
        <div ref="chartRef" style="width: 100%; height: 400px"></div>
      </div>
    </a-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, onMounted, onUnmounted } from 'vue'
import { message } from 'ant-design-vue'
import { pollApi } from '@/api/interactionController'
import socketService from '@/utils/socket'
import * as echarts from 'echarts'

// å“åº”å¼æ•°æ®
const loading = ref(false)
const polls = ref([])
const pagination = reactive({
  current: 1,
  pageSize: 10,
  total: 0
})

const isTeacher = ref(true) // ä»ç”¨æˆ·ä¿¡æ¯è·å–
const isStudent = ref(false)

const createModalVisible = ref(false)
const voteModalVisible = ref(false)
const resultsModalVisible = ref(false)

const pollForm = reactive({
  title: '',
  description: '',
  pollType: 'single',
  options: [
    { id: 1, text: '' },
    { id: 2, text: '' }
  ],
  timeRange: [],
  isAnonymous: false
})

const currentPoll = ref(null)
const selectedOptions = ref([])
const pollResults = ref(null)
const chartRef = ref(null)

// åŠ è½½æŠ•ç¥¨åˆ—è¡¨
const loadPolls = async () => {
  loading.value = true
  try {
    const response = await pollApi.getPollList({
      courseId: 1, // ä»è·¯ç”±æˆ–storeè·å–
      page: pagination.current,
      perPage: pagination.pageSize
    })
    
    polls.value = response.data.items
    pagination.total = response.data.pagination.total
  } catch (error) {
    message.error('åŠ è½½æŠ•ç¥¨åˆ—è¡¨å¤±è´¥')
  } finally {
    loading.value = false
  }
}

// æ˜¾ç¤ºåˆ›å»ºå¯¹è¯æ¡†
const showCreateModal = () => {
  createModalVisible.value = true
}

// åˆ›å»ºæŠ•ç¥¨
const handleCreatePoll = async () => {
  try {
    const data = {
      title: pollForm.title,
      description: pollForm.description,
      courseId: 1,
      pollType: pollForm.pollType,
      options: pollForm.options.filter(opt => opt.text.trim()),
      isAnonymous: pollForm.isAnonymous,
      startTime: pollForm.timeRange[0],
      endTime: pollForm.timeRange[1]
    }
    
    const response = await pollApi.createPoll(data)
    
    // é€šè¿‡WebSocketé€šçŸ¥å…¶ä»–ç”¨æˆ·
    socketService.emitPollCreated(1, response.data)
    
    message.success('æŠ•ç¥¨åˆ›å»ºæˆåŠŸ')
    createModalVisible.value = false
    loadPolls()
  } catch (error) {
    message.error('åˆ›å»ºæŠ•ç¥¨å¤±è´¥')
  }
}

// æ·»åŠ é€‰é¡¹
const addOption = () => {
  const newId = Math.max(...pollForm.options.map(o => o.id)) + 1
  pollForm.options.push({ id: newId, text: '' })
}

// åˆ é™¤é€‰é¡¹
const removeOption = (index: number) => {
  pollForm.options.splice(index, 1)
}

// æŠ•ç¥¨
const votePoll = (poll: any) => {
  currentPoll.value = poll
  selectedOptions.value = []
  voteModalVisible.value = true
}

// æäº¤æŠ•ç¥¨
const handleVote = async () => {
  try {
    const data = {
      selectedOptions: Array.isArray(selectedOptions.value) 
        ? selectedOptions.value 
        : [selectedOptions.value]
    }
    
    await pollApi.vote(currentPoll.value.id, data)
    
    // é€šçŸ¥æŠ•ç¥¨ç»“æœæ›´æ–°
    const results = await pollApi.getPollResults(currentPoll.value.id)
    socketService.emitPollVoted(1, currentPoll.value.id, results.data)
    
    message.success('æŠ•ç¥¨æˆåŠŸ')
    voteModalVisible.value = false
    loadPolls()
  } catch (error) {
    message.error('æŠ•ç¥¨å¤±è´¥')
  }
}

// æŸ¥çœ‹ç»“æœ
const viewResults = async (poll: any) => {
  try {
    const response = await pollApi.getPollResults(poll.id)
    pollResults.value = response.data
    resultsModalVisible.value = true
    
    // æ¸²æŸ“å›¾è¡¨
    setTimeout(() => {
      renderChart()
    }, 100)
  } catch (error) {
    message.error('åŠ è½½ç»“æœå¤±è´¥')
  }
}

// æ¸²æŸ“å›¾è¡¨
const renderChart = () => {
  if (!chartRef.value || !pollResults.value) return
  
  const chart = echarts.init(chartRef.value)
  
  const option = {
    title: {
      text: 'æŠ•ç¥¨ç»“æœç»Ÿè®¡'
    },
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'shadow'
      }
    },
    xAxis: {
      type: 'category',
      data: pollResults.value.optionStats.map(s => s.optionText)
    },
    yAxis: {
      type: 'value'
    },
    series: [{
      name: 'ç¥¨æ•°',
      type: 'bar',
      data: pollResults.value.optionStats.map(s => s.count),
      itemStyle: {
        color: '#1890ff'
      }
    }]
  }
  
  chart.setOption(option)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  loadPolls()
  
  // è¿æ¥WebSocket
  socketService.connect()
  socketService.joinCourse(1, 1) // courseId, userId
  
  // ç›‘å¬æ–°æŠ•ç¥¨
  socketService.onNewPoll((data) => {
    message.info('æœ‰æ–°çš„æŠ•ç¥¨')
    loadPolls()
  })
  
  // ç›‘å¬æŠ•ç¥¨ç»“æœæ›´æ–°
  socketService.onPollResultsUpdated((data) => {
    if (resultsModalVisible.value && pollResults.value) {
      // æ›´æ–°ç»“æœ
      loadPolls()
    }
  })
})

onUnmounted(() => {
  socketService.leaveCourse(1, 1)
})
</script>

<style scoped lang="scss">
.poll-page {
  padding: 24px;
}

.option-item {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}
</style>
```

**æç¤º**: ç±»ä¼¼çš„æ–¹å¼åˆ›å»º `QuestionPage.vue` å’Œ `BarragePage.vue`

---

## äº”ã€æµ‹è¯•ä¸ä¼˜åŒ–

### 5.1 åŠŸèƒ½æµ‹è¯•æ¸…å•

- [ ] æŠ•ç¥¨åˆ›å»ºã€ç¼–è¾‘ã€åˆ é™¤
- [ ] å­¦ç”ŸæŠ•ç¥¨åŠŸèƒ½
- [ ] æŠ•ç¥¨ç»“æœå®æ—¶æ›´æ–°
- [ ] æé—®åˆ›å»ºã€å›ç­”
- [ ] ç­”æ¡ˆé‡‡çº³ã€ç‚¹èµ
- [ ] å¼¹å¹•å‘é€ã€å±•ç¤º
- [ ] æ•æ„Ÿè¯è¿‡æ»¤
- [ ] WebSocketè¿æ¥ç¨³å®šæ€§

### 5.2 å¹¶å‘æµ‹è¯•

ä½¿ç”¨å·¥å…·æµ‹è¯•å¤šç”¨æˆ·åŒæ—¶æ“ä½œï¼š
- 100ä¸ªå­¦ç”ŸåŒæ—¶æŠ•ç¥¨
- 50ä¸ªå­¦ç”ŸåŒæ—¶å‘é€å¼¹å¹•
- WebSocketè¿æ¥æ•°å‹åŠ›æµ‹è¯•

### 5.3 æ€§èƒ½ä¼˜åŒ–

1. **åç«¯ä¼˜åŒ–**:
   - Redisç¼“å­˜æŠ•ç¥¨ç»“æœ
   - æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–ï¼ˆæ·»åŠ ç´¢å¼•ï¼‰
   - WebSocketæ¶ˆæ¯æ‰¹é‡å¤„ç†

2. **å‰ç«¯ä¼˜åŒ–**:
   - è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¼¹å¹•åˆ—è¡¨ï¼‰
   - é˜²æŠ–èŠ‚æµï¼ˆæœç´¢ã€å‘é€ï¼‰
   - å›¾è¡¨æ‡’åŠ è½½

---

## å…­ã€å¼€å‘æ—¶é—´ä¼°ç®—

| é˜¶æ®µ | ä»»åŠ¡ | é¢„è®¡æ—¶é—´ |
|------|------|---------|
| åç«¯ | Serviceå±‚å¼€å‘ | 1å¤© |
| åç«¯ | APIæ¥å£å¼€å‘ | 1å¤© |
| åç«¯ | WebSocketé›†æˆ | 1-1.5å¤© |
| å‰ç«¯ | APIå°è£… | 0.5å¤© |
| å‰ç«¯ | é¡µé¢ç»„ä»¶å¼€å‘ | 2å¤© |
| å‰ç«¯ | WebSocketé›†æˆ | 1å¤© |
| å‰ç«¯ | æ•°æ®å¯è§†åŒ– | 0.5å¤© |
| æµ‹è¯• | åŠŸèƒ½æµ‹è¯•+ä¼˜åŒ– | 1-2å¤© |
| **æ€»è®¡** | | **8-10å¤©** |

---

## ä¸ƒã€æ³¨æ„äº‹é¡¹

### 7.1 å…³é”®ç‚¹

1. **å¤–é”®è§„èŒƒ**: æ¨¡å‹ä¸­ä¸ä½¿ç”¨`ForeignKey`çº¦æŸï¼Œåªç”¨æ³¨é‡Šæ ‡è®°
2. **è£…é¥°å™¨é¡ºåº**: `@staticmethod` â†’ `@xxx_api_bp.get()` â†’ `@login_required`
3. **å“åº”æ ¼å¼**: ç»Ÿä¸€ä½¿ç”¨`ResponseHandler`
4. **WebSocketæˆ¿é—´**: ä½¿ç”¨`course_{course_id}`æ ¼å¼

### 7.2 å¸¸è§é—®é¢˜

**Q: WebSocketè¿æ¥å¤±è´¥ï¼Ÿ**
A: æ£€æŸ¥CORSé…ç½®ï¼Œç¡®ä¿å‰ç«¯URLåœ¨å…è®¸åˆ—è¡¨ä¸­

**Q: æŠ•ç¥¨ç»“æœä¸å®æ—¶æ›´æ–°ï¼Ÿ**
A: ç¡®è®¤WebSocketäº‹ä»¶ç›‘å¬æ­£ç¡®ï¼Œæ£€æŸ¥æˆ¿é—´åŠ å…¥æ˜¯å¦æˆåŠŸ

**Q: æ•æ„Ÿè¯è¿‡æ»¤ä¸ç”Ÿæ•ˆï¼Ÿ**
A: æ£€æŸ¥`BarrageService.SENSITIVE_WORDS`åˆ—è¡¨ï¼Œå¯ä»¥æ‰©å±•ä¸ºæ•°æ®åº“é…ç½®

---

## å…«ã€ä¸‹ä¸€æ­¥å·¥ä½œ

å®Œæˆè¯¾å ‚äº’åŠ¨æ¨¡å—åï¼Œå¯ä»¥ç»§ç»­å¼€å‘ï¼š
1. **è€ƒå‹¤æ¨¡å—** - äºŒç»´ç ç­¾åˆ°
2. **æˆç»©æ¨¡å—** - Excelå¯¼å…¥å¯¼å‡º
3. **æ™ºèƒ½æ¨¡å—** - èµ„æ–™è‡ªåŠ¨å½’ç±»

---

**ç¥å¼€å‘é¡ºåˆ©ï¼æœ‰é—®é¢˜éšæ—¶é—®æˆ‘ ğŸš€**
